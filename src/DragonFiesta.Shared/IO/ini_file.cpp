//
// Copyright (c) 2006 Alexis Wilke
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Find documentation on the home website:
//
//	http://boost-extras.sourceforge.net/
//	http://boost-extras.sourceforge.net/ini_file/ini_file.html
//
#include	"ini_file.hpp"
#include	<iostream>

namespace ini_file
{
const param param_map::m_empty("");
const section section_map::m_empty("");

std::istream& operator >> (std::istream& in, section_map& _section_map)
{
    boost::shared_ptr<section>	sec;
    boost::shared_ptr<param>	par;
    std::string					result, comment, name;
    char						c, quote;
    const char					*s, *e;
    int							line, i;

    line = 0;
    while(!in.eof() && !!in)
    {
        ++line;
        getline(in, result);

        if(result.size() == 0) continue;
        switch(c = result[0])
        {
        case '#':
            // comment
            if(comment.size() > 0)
            {
                comment += "\n";
            }
            s = result.c_str() + 1;
            while(isspace(*s))
            {
                ++s;
            }
            comment += s;
            break;

        case '[':
            // section
            s = result.c_str() + 1;
            e = result.c_str() + result.size();
            while(s < e && isspace(s[0]))
            {
                ++s;
            }
            while(e > s && isspace(e[-1]))
            {
                --e;
            }
            if(e[-1] != ']')
            {
                // name must end with ']' + optional spaces
                throw ini_exceptions::invalid_section_name();
            }
            --e;
            while(e > s && isspace(e[-1]))
            {
                --e;
            }
            if(e == s)
            {
                // name mustn't be empty
                throw ini_exceptions::invalid_section_name();
            }
            // valid section name, create section
            sec.reset(new section(result.substr(s - result.c_str(), e - s)));
            sec->set_comment(comment);
            comment.clear();
            _section_map.insert(sec);
            break;

        default:
            // make sure the variable starts with a letter or _
            // (there is no spec. for that, but it feels sensical;
            // should that apply to section names?)
            if((c >= 'a' || c <= 'z')
                    && (c >= 'A' || c <= 'Z')
                    && c == '_')
            {
                if(isspace(c))
                {
                    // note the loop does not test 'result[0]'
                    // since we just checked it (it's in 'c')
                    i = result.size() - 1;
                    while(i > 0 && isspace(result[i]))
                    {
                        --i;
                    }
                    if(i == 0)
                    {
                        // empty line with just spaces
                        continue;
                    }
                }
                // unsure what this is
                throw ini_exceptions::invalid_param_name();
            }
            if(!sec)
            {
                // variables before a section is not valid
                throw ini_exceptions::param_without_section();
            }
            s = result.c_str();
            e = s + 1;
            while(!isspace(*e) && *e != '=')
            {
                ++e;
            }
            // This case cannot happen since we start with e = s + 1.
            //if(e == s) {
            //	// empty variable names are not acceptable
            //	throw ini_exceptions::invalid_param_name();
            //}
            par.reset(new param(result.substr(0, e - s)));
            while(isspace(*e))
            {
                ++e;
            }
            if(*e != '=')
            {
                // variable names must be followed by '='
                throw ini_exceptions::invalid_parameter();
            }
            ++e;
            while(isspace(*e))
            {
                ++e;
            }
            quote = *e;
            if(quote == '"' || quote == '\'')
            {
                // quoted value
                ++e;
                s = e;
                while(*e != quote && *e != '\0')
                {
                    // allow escaping, but keep the backslashes
                    // TODO: which is wrong!
                    if(*e == '\\' && e[1] == quote)
                    {
                        ++e;
                    }
                    ++e;
                }
                if(*e != quote)
                {
                    throw ini_exceptions::invalid_quotation();
                }
                // warning: we ignore what follows
            }
            else
            {
                s = e;
                e = result.c_str() + result.size();
                while(e > s && isspace(e[-1]))
                {
                    --e;
                }
            }
            par->set_value(result.substr(s - result.c_str(), e - s));
            par->set_comment(comment);
            comment.clear();
            sec->insert(par);
            break;

        }
    }
    return in;
}

namespace details
{
std::ostream& operator << (std::ostream& out, const name& _name)
{
    return out << _name.get_name();
}
std::ostream& operator << (std::ostream& out, const comment& _comment)
{
    // TODO:
    // we would need a filter for comments, but I'm not too sure we can
    // do that (i.e. add a filter, write the comment, remove the filter)
    bool new_line = true;
    std::string::const_iterator i;
    std::string::const_iterator end = _comment.get_comment().end();
    for(i = _comment.get_comment().begin(); i != end; ++i)
    {
        if(*i == '\r' || *i == '\n')
        {
            out << *i;
            new_line = true;
        }
        else
        {
            if(new_line)
            {
                out << "; ";
            }
            new_line = false;
            out << *i;
        }
    }
    if(!new_line)
    {
        out << std::endl;
    }
    return out;
}
}

std::ostream& operator << (std::ostream& out, const param& _param)
{
    if(_param.get_name().size() == 0)
    {
        if(_param.get_value().size() == 0)
        {
            return out;
        }
        throw ini_exceptions::param_name_missing();
    }

    // output <comment> and then '<name>='
    out << static_cast<const details::comment&>(_param)
        << static_cast<const details::name&>(_param)
        << '=';

    // output <value>, check whether we need quotation
    const std::string& value = _param.get_value();
    const char *s = value.c_str();
    const char *e = s + value.size();
    if(*s == '"' || *s == '\'' || isspace(*s) || (e > s && isspace(e[-1])))
    {
        // need quotation to not lose any data
        char quote = '\0';
        while(*s != '\0')
        {
            if(*s == '\'')
            {
                quote = '"';
                break;
            }
            if(*s == '"')
            {
                quote = '\'';
                break;
            }
            ++s;
        }
        s = value.c_str();
        out << quote;
        while(*s != '\0')
        {
            if(*s == quote)
            {
                out << "\\";
            }
            out << *s;
            ++s;
        }
        out << quote;
    }
    else
    {
        // no quotation necessary
        out << value;
    }

    out << std::endl;

    return out;
}

std::ostream& operator << (std::ostream& out, const param_map& _param_map)
{
    param_map::const_iterator i = _param_map.begin();
    param_map::const_iterator end = _param_map.end();
    while(i != end)
    {
        out << *(*i).second;
        ++i;
    }
    return out;
}

std::ostream& operator << (std::ostream& out, const section& _section)
{
    if(_section.get_name().size() == 0)
    {
        if(_section.size() == 0)
        {
            return out;
        }
        throw ini_exceptions::section_name_missing();
    }

    return out
           << static_cast<const details::comment&>(_section)
           << '[' << static_cast<const details::name&>(_section) << ']' << std::endl
           << static_cast<const param_map&>(_section);
}
std::ostream& operator << (std::ostream& out, const section_map& _section_map)
{
    section_map::const_iterator i = _section_map.begin();
    section_map::const_iterator end = _section_map.end();
    while(i != end)
    {
        out << *(*i).second;
        out << std::endl;
        ++i;
    }
    return out;
}




}		// namespace ini_file
// vim: ts=4
