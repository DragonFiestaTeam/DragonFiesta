//
// Copyright (c) 2006 Alexis Wilke
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Find documentation on the home website:
//
//	http://boost-extras.sourceforge.net/
//	http://boost-extras.sourceforge.net/ini_file/ini_file.html
//
#ifndef BOOST_EXTRAS_INI_FILE
#define	BOOST_EXTRAS_INI_FILE 1

#include	<boost/shared_ptr.hpp>
#include	<exception>
#include	<string>
#include	<map>
#include	<iostream>

namespace ini_file
{


namespace ini_exceptions
{
class ini_file_exception    : std::exception {};
class section_name_missing  : ini_file_exception {};
class invalid_section_name  : ini_file_exception {};
class param_name_missing    : ini_file_exception {};
class invalid_param_name    : ini_file_exception {};
class invalid_parameter     : ini_file_exception {};
class param_without_section : ini_file_exception {};
class invalid_quotation     : ini_file_exception {};
}		// namespace ini_exceptions


namespace details
{
struct name
{
    name(const std::string& _name) : m_name(_name) {}
    virtual ~name() {}
    //void set_name(const std::string& _name) { m_name = _name; }
    const std::string& get_name() const
    {
        return m_name;
    }

private:
    const std::string m_name;
};
extern std::ostream& operator << (std::ostream& out, const name& _name);
struct comment
{
    virtual ~comment() {}
    void set_comment(const std::string& _comment)
    {
        m_comment = _comment;
    }
    const std::string& get_comment() const
    {
        return m_comment;
    }

private:
    std::string m_comment;
};
extern std::ostream& operator << (std::ostream& out, const comment& _comment);
}		// namespace details


struct param : details::name, details::comment
{
    param(const std::string& _name) : details::name(_name) {}
    void set_value(const std::string& _value)
    {
        m_value = _value;
    }
    const std::string& get_value() const
    {
        return m_value;
    }

    param& operator = (const std::string& _value)
    {
        set_value(_value);
        return *this;
    }
    operator const std::string& () const
    {
        return m_value;
    }
private:
    std::string m_value;
};
namespace details
{
typedef std::map<std::string, boost::shared_ptr<param> > param_map_t;
}
struct param_map : details::param_map_t
{
    void insert(boost::shared_ptr<param> _p)
    {
        if(_p)
        {
            details::param_map_t::insert(details::param_map_t::value_type(_p->get_name(), _p));
        }
    }
    param& operator [] (const std::string& _name)
    {
        details::param_map_t::iterator i = details::param_map_t::find(_name);
        if(i == end())
        {
            boost::shared_ptr<param> p(new param(_name));
            insert(p);
            return *p;
        }
        return *i->second;
    }
    const param& operator [] (const std::string& _name) const
    {
        details::param_map_t::const_iterator i = details::param_map_t::find(_name);
        if(i == end()) return m_empty;
        return *i->second;
    }

private:
    static const param m_empty;
};



struct section : details::name, details::comment, param_map
{
    section(const std::string& _name) : details::name(_name) {}
};
namespace details
{
typedef std::map<std::string, boost::shared_ptr<section> > section_map_t;
}
struct section_map : details::section_map_t
{
    void insert(boost::shared_ptr<section> _s)
    {
        if(_s)
        {
            details::section_map_t::insert(details::section_map_t::value_type(_s->get_name(), _s));
        }
    }
    const section& operator [] (const std::string& _name) const
    {
        details::section_map_t::const_iterator i = details::section_map_t::find(_name);
        if(i == end()) return m_empty;
        return *i->second;
    }
    section& operator [] (const std::string& _name)
    {
        details::section_map_t::iterator i = details::section_map_t::find(_name);
        if(i == end())
        {
            boost::shared_ptr<section> s(new section(_name));
            insert(s);
            return *s;
        }
        return *i->second;
    }
private:
    static const section m_empty;
};





extern std::istream& operator >> (std::istream& in, section_map& _section_map);

extern std::ostream& operator << (std::ostream& out, const param& _param);
extern std::ostream& operator << (std::ostream& out, const section& _section);

extern std::ostream& operator << (std::ostream& out, const param_map& _param_map);
extern std::ostream& operator << (std::ostream& out, const section_map& _section_map);



}	// namespace ini_file


#endif // #ifdef BOOST_EXTRAS_INI_FILE
// vim: ts=4
